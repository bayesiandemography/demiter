% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/increment.R
\name{increment}
\alias{increment}
\alias{iter_create_increment}
\alias{iter_next_increment}
\alias{iter_has_next_increment}
\title{Increment iterators}
\usage{
iter_create_increment(spec)

iter_next_increment(iter)

iter_has_next_increment(iter)
}
\arguments{
\item{spec}{An object of class \code{\link{SpecIterIncrement}}.}

\item{iter}{An increment iterator.}
}
\description{
An increment iterator traverses array \code{self}
giving the indices for an associated array, or pair of arrays,
of (net) increments. Every cell in \code{self} maps on
to a single cell in the associated array(s). Every cell
in the associated array(s) maps on to one or more cells
in \code{self}.
}
\details{
Array \code{self} describes events, such as births,
deaths, or migration, that affect the size and structure
of a population. Array \code{self} must have a time dimension.
It may have an age dimension. If it does, it must also have a
triangle dimension. It may not have have cohort dimension.

Array \code{self} must have positive length. None of
its dimensions can have length zero.

If \code{self} has pairs of origin-destination dimensions
or parent-child dimensions, then the destination dimensions
or child dimensions are mapped into \code{oth}. The origin
diemnsions or parent dimensions are dropped. The rule
that parent dimensions are dropped extends to the age
dimension when \code{self} is births. Age in this case
refers to the parent, and so is not included in \code{oth}.

If \code{self} does not have age and triangle dimensions,
then there is a single \code{oth} array holding net increments.
If \code{self} does have age and triangle dimensions,
then there are two \code{oth} arrays. The first \code{oth} array
holds increments derived from lower Lexis triangles, and the second
\code{oth} array holds increments derived from upper Lexis triangles.

If \code{self} and \code{oth} share a dimension, then the two
versions of the dimension must match exactly, in that they
have exactly the same categories in exactly the same order.
The one partial exception to this rule is time. If \code{oth}
is population at the end of the period, then the time dimension
for \code{oth} will consist of points, while the
time dimension of \code{self} consists of intervals.

The array \code{self} can belong to one of four types:
\code{"increment"}, \code{"decrement"},\code{"orig-dest"},
and \code{"pool"}. Arrays of births or immigrations
are examples of increments. If \code{self} is an increment array, then
the value in each cell of \code{self} is added to the value of the
associated cell in \code{oth}. Arrays of deaths or emigrations
are examples of decrements. If \code{self} is a decrement array,
then the value in each cell of \code{self} is subtracted from the
value of the associated cell in \code{oth}.
Orig-dest and pool arrays are different ways of
representing movements between regions or other statuses. The
value in each cell of \code{self} is subtracted from one
cell in \code{oth} and added to another cell in \code{oth}.
The cell that is subtracted from and the cell that is added to
can be the same, so that the net increment is zero.

Function \code{iter_next_cohort} returns an integer vector of length
three. The first element of this vector takes a value of \code{1}
if there is a single \code{oth} array; a value of \code{2} if there
are two \code{oth} arrays, and the cell of \code{self}
maps on to the array for lower Lexis triangles; and
a value of \code{3} if there are two \code{oth} arrays
and the cell of \code{self} maps on to the
array for upper Lexis triangles. The second element of the integer vector
gives the index of the cell in the \code{oth} array
that is to be incremented. If no cell in the \code{oth} array is
to be incremented, then the index is \code{0}.
 The third element of the integer vector gives the index of the cell
in the \code{oth} array whose value that is to be decremented.
if no cell in the \code{oth} array is to be decremented,
then the index is is \code{0}.
}
\examples{
spec <- SpecIterIncrement(dim_self = c(3, 3),
                          dim_oth = 3,
                          map_dim = c(0, 1),
                          comp_type_self = "orig-dest",
                          indices_orig_self = 1,
                          indices_dest_self = 2)
iter <- iter_create_increment(spec)
for (i in 1:9) {
    print(iter_has_next_increment(iter))
    print(iter_next_increment(iter))
}
iter_has_next_increment(iter)
}
\seealso{
\code{\link{SpecIterIncrement}}, \code{\link{cohort}},
\code{\link{increment}}
}
