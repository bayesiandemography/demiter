% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/increment.R
\name{increment}
\alias{increment}
\alias{iter_create_increment}
\alias{iter_next_increment}
\alias{iter_has_next_increment}
\title{Increment iterators}
\usage{
iter_create_increment(spec)

iter_next_increment(iter)

iter_has_next_increment(iter)
}
\arguments{
\item{spec}{An object of class \code{\link{SpecIterIncrement}}.}

\item{iter}{An increment iterator.}
}
\description{
An increment iterator traverses array \code{self}
giving the indices for associated arrays of (net) increments.
}
\details{
Array \code{self} describes events, such as births,
deaths, or migration, that affect the size and structure
of a population. Array \code{self} must have a dimension with
dimtype \code{"time"}, consisting of intervals of equal lengths.
If \code{self} has a dimension with dimtype \code{"age"}, then
that dimenions must consist of intervals with equal lengths,
except for the last interval, which must be open. In addition,
if \code{self} has an age dimension, then \code{self}
must also have a dimension with dimtype \code{"triangle"}.

If \code{self} does not have age and triangle dimensions
then there is a single \code{oth} array. The \code{oth} array
describes the effect of the component on population size
at the end of each period.
If \code{self} does have age and triangle dimensions, then there
are two \code{oth} arrays. The first \code{oth} array describes the
effect of the component on population at the end of each period,
which is calculated from lower Lexis triangles. The second \code{oth}
array records the effect of the component on accession to the
next age group during each period, which is calculated from upper
Lexis triangles.

If \code{self} and \code{oth} share a dimension, then the two
versions of the dimension must match exactly, in that they
have exactly the same categories in exactly the same order.
The one partial exception to this rule is time. If \code{oth}
is population at the end of the period, then the time dimension
for \code{oth} will consist of points, while the
time dimension of \code{self} consists of intervals.

If \code{self} is births, and has a dimension with dimtype
\code{"age"}, then age refers to the parent,
not to the child. However, births increase the number of children,
not the number of people of child-bearing age. 
The age dimension in \code{self} therefore does not
correspond to the age dimension in the associated array
of increments.

The array \code{self} can belong to one of four types: increment, decrement,
origin-destination, and pool. Arrays of births or immigrations
are examples of increments. If \code{self} is an increment array,
the value in each cell of \code{self} is added to the value of the
associated cell in  \code{oth}. Arrays of deaths or emigrations
are examples of decrements. If \code{self} is a decrement array,
the value in each cell of \code{self} is subtracted from the
value of the associated cell in \code{oth}.
Origin-destination arrays and pool arrays are different ways of
representing movements between regions or other statuses. The
value in each cell of \code{self} is subtracted from one
cell in \code{oth} and added to another cell.

Function \code{iter_next_cohort} returns an integer vector of length
three. The first element of this vector takes a value of \code{1}
if \code{oth} represents population at the end of the period,
and a value of \code{2} if \code{oth} represents accession
during the period. The second element of the integer vector
gives the index of the cell in \code{oth} whose value should
be increased by the value of the cell in \code{self}. If
contributes to increasing. If \code{self} is a decrement
array, then the second element is \code{0}. The third element of the
integer vector gives the index of the cell in \code{oth} whose value
should be decreased by the value of the cell in \code{self}. If
\code{self} is an increment array, then the third element is \code{0}.
}
\examples{
spec <- SpecIterIncrement(dim_self = c(3, 3),
                          dim_oth = 3,
                          map_dim = c(1, 0),
                          comp_type_self = "orig-dest",
                          indices_orig_self = 1,
                          indices_dest_self = 1)
iter <- iter_create_increment(spec)
for (i in 1:9) {
    print(iter_has_next_increment(iter))
    print(iter_next_increment(iter))
}
iter_has_next_increment(iter)
}
\seealso{
\code{\link{SpecIterIncrement}}, \code{\link{cohort}},
\code{\link{increment}}
}
